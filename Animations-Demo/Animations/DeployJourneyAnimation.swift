import SpriteKit
// animation data in FloatingLabelData.

class DeployJourneyAnimation: Animation {
    var bgImage: SKNode!
    var dashedSplinePath: CustomDashedSpline!

    var destinationLabeledIcons: [DestinationIconType:LabeledIcon] = [:]
    var pathPositions: [CGPoint] { return destinationOrder.map { destinationPositions[$0]! } }
    var pathPositionsCopy: [CGPoint] = []
    
    override func setupNodes() {
        self.bgImage = SKSpriteNode(imageNamed: "middle-earth-map-re-color.png")
        self.pathPositionsCopy = pathPositions
        
        bgImage.zPosition = -10
        bgImage.position = self.scene!.getCenter()
        bgImage.setScale(2.0)
        
        var splineShapeNode = SKShapeNode(splinePoints: &pathPositionsCopy, count: pathPositionsCopy.count)
        var splinePath = splineShapeNode.path!
        
        dashedSplinePath = CustomDashedSpline(sourcePath: splinePath )
        dashedSplinePath.position = self.scene!.getCenter()
        dashedSplinePath.setPathFractions(destinationFractions())

        appendNode(dashedSplinePath)
        
        appendNode(bgImage)
        buildLabeledIcons()
    }
    
    func destinationFractions() -> [Float] {
        // linear approximation for animating the progress across autogenerated spline.
        var length:Float = 0.0
        var prevPoint = pathPositions.first
        //calc length
        for i in 1..<pathPositions.count {
            let destination = pathPositions[i]
            length += distance(prevPoint!.toSIMDFloat, destination.toSIMDFloat)
            prevPoint = destination
        }
        
        //calculating each segments distance
        var outputSegmentPercentLengths = [Float].init(repeating: 0.0, count: pathPositions.count)
        var fractionSum: Float = 0.0
        prevPoint = pathPositions.first
        // first output value is 0.0
        for i in 1..<pathPositions.count {
            let destination = pathPositions[i]
            fractionSum += distance(prevPoint!.toSIMDFloat, destination.toSIMDFloat) / length
            outputSegmentPercentLengths[i] = fractionSum
            prevPoint = destination
        }
        
        return outputSegmentPercentLengths
    }
    
    // convenient to combine Icon and Floating Label building into one function with nodes.
    private func buildLabeledIcons() {
        for (title, descriptionText, destinationType) in deployJourneyDescriptionData {
            let isRight = rightDestinationLabels.contains(destinationType)
            let fileName = destinationFileNames[destinationType] ?? "sample text"
            var position = destinationPositions[destinationType] ?? CGPoint(0.0)
            position = position + (self.scene?.getCenter() ?? CGPoint(0.0)) //floating point += support missing
            
            let labeledIconNode = LabeledIcon(labelOnRight: isRight,
                                              fileName: fileName,
                                              center: position,
                                              title: title,
                                              description: descriptionText
                                             )
            destinationLabeledIcons.updateValue(labeledIconNode,
                                                forKey: destinationType)
            appendNode(labeledIconNode)
        }
    }
    
    override func setupAnimationCode() {
        // first animate camera going to each destination, and fade in floating labels describing destination.
        for (i, destination) in destinationOrder.enumerated() {
            // camera goes to each destination
            addAnimationFrame {
                guard let animationScene = (self.scene as? AnimationScene) else { return }
                animationScene.moveCam(to: destinationPositions[destination]! + animationScene.getCenter(), d: 1.0)
            }
            
            if let floatingLabel = destinationLabeledIcons[destination]?.label {
                //title fade in
                addAnimationFrame {
                    self.addChild(floatingLabel)
                    floatingLabel.animateFadeIn()
                    if ( i == 0 ) {
                        (self.scene as! AnimationScene).zoomCam(s: 1.0, d: 1.6)
                    }
                }
                // description fade in
                addAnimationFrame {
                    floatingLabel.animateFadeIn()
                }
                //fade out
                addAnimationFrame {
                    floatingLabel.animateFadeOut()
                }
            }
        }
        
        // Then after we can animate the red dotted path journey
        for (i, destination) in destinationOrder.enumerated() {
            addAnimationFrame {
                guard let animationScene = (self.scene as? AnimationScene) else { return }
                animationScene.moveCam(to: destinationPositions[destination]! + animationScene.getCenter(), d: 1.0)
            
                if i != 0 {
                    self.dashedSplinePath.animate(from: i - 1, to: i)
                }
            }
        }
        
        addAnimationFrame {
            print("last spacer frame!")
        }
    }
    
    override func cleanup() {
        dashedSplinePath.reset()
        // dont retain nodes, cant rerun the animation without bugs otherwise
        destinationLabeledIcons = [:]
    }
}

